## Конструкции с if, циклы

Сегодня нас ждет сложный и объемный урок. Рекомендую обращаться к нему до тех пор, пока концепции не будут усвоены.

### Конструкции с if
Задача:
Есть строка, со стоящая из некоего символа. Необходимо вывести на печать сообщение, является ли символ буквой или цифрой.

Давайте прикинем, как бы мы могли это сделать. Очевидно у нас есть условие `если-то`. Как раз для таких случаев в питоне есть конструкция с `if`.
В общем случае оператор `if` работает по следующему принципу:
```py
if условие_1 выполнено:
	действие_1
elif условие_2 выполнено:
	действие_2
else:
	действие_3 # выполняется, если ни одно из условий выше не выполнено
```

В своих задачах вы можете использовать эту конструкцию в нескольких комбинациях:
- `if`
- `if-else`
- `if-elif-else`

Утверждений с elif может быть несколько - столько, сколька вам требуется.
Давайте попробуем решить задачу выше.

1. Предположим, дана строка s = '3'. Перефразируем задачу в условии "если-то":
Если символ является цифрой, печатай "это цифра", если же символ является буквой, печатай "это буква".
2. Поскольку в условии не говориться ничего о том, какие символы участвуют в рассмотрении, добавим, что в прочих случаях следует вывести "символ не является ни буквой, ни числом".
3. Перенесем на язык питон:
 ```py
 s = '3'
 
 if s.isalpha():
 	print("это буква")
 elif s.isdigit():
 	print("это цифра")
 else:
 	print("символ не является ни буквой, ни цифрой")
 
 >>> это цифра
 ```

Подмените символ на букву, а потом, например, на точку и проверьте, что скрипт работает верно.

#### Задачи:
1. Ввести число. Если оно неотрицательно, вычесть из него 10, в противном случае прибавить к нему 10.
Для решения этой задачи нам потребуется ввести что-то с клавиатуры. Как же это сделать?
Погуглим и узнаем, что конструкция input() позволяет вводить данные с клавиатуры.
2. Введите два числа. Если их сумма кратна 5, прибавить 1, иначе вычесть 2.
3. Составить программу, которая спрашивает возраст человека и, если ему 18 лет и больше, сообщает “Замечательно. Вы уже можете водить автомобиль”, а в противном случае – “К сожалению, водить автомобиль Вам рановато”.
4. Составьте выражение, которое в зависимости от указанного месяца (числом) выводит на печать следующее: 
«Вы родились <НАЗВАНИЕ_СЕЗОНА>.». 
Важно учесть, что пользователи могут ввести любой тип данных в качестве аргумента (не попадитесь на этом и предупредите о том, что «Требуется ввести реальный номер месяца»).


### Циклы
![](https://i.imgur.com/8npWHSC.png)

Действие циклов заключается в последовательном повторении определенной части вашей программы некоторое количество раз. Повторение продолжается до тех пор, пока выполняется соответствующее условие. Когда значение выражения, задающего условие, становится ложным, выполнение цикла прекращается.

#### While
Цикл `while` (“пока”) позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно. Условие записывается до тела цикла и проверяется до выполнения тела цикла. Как правило, цикл `while` используется, когда невозможно определить точное значение количества проходов исполнения цикла.
`While` - это более простой цикл. Он не позволит итерироваться по последовательностям напрямую. Ему обязательно нужно условие и счетчик

```py
i = 0
while i < 10:
    print(i)
    i = i + 1
```
Если вы запустите этот код, он выдаст от 0 до 9, каждая цифра будет в отдельной строке, после чего задача будет выполнена. Если вы удалите ту часть, в которой мы увеличиваем значение i, то мы получим **бесконечный цикл**. Как правило – это плохо, нобывают исключения. **Бесконечные циклы** известны как логические ошибки, и их нужно избегать. Существует другой способ вырваться из цикла, для этого нужно использовать встроенную функцию **break**.

```py
i = 0
while i < 10:
    print(i)
    
    if i == 5:
        break
    
    i += 1
```
В этой части кода мы добавили условное выражение для проверки того, равняется ли когда-либо переменная i цифре 5. Если нет, тогда мы **разрываем цикл**. Как вы видите в выдаче кода, как только значение достигает пяти, код останавливается, даже если мы ранее указали **while** продолжать цикл, пока переменная не достигнет значения 10.
Встроенный **break** также известен как инструмент управления потока.

Существует еще один, под названием **continue**, который в основном используется для пропуска итерации, или перейти к следующей итерации.

```py
i = 0
 
while i < 10:
    if i == 3:
        i += 1
        continue
    
    print(i)
    if i == 5:
        break
    
    i += 1
```
Мы добавили второе условное выражение, которое проверяет, не равняется ли i трем. Если да, мы увеличиваем переменную и переходим к **следующему циклу**, который удачно пропускает вывод значения 3 на экран. Как и ранее, когда мы достигаем значения 5, мы **разрываем цикл**. Существует еще одна тема, касающаяся циклов, которую нам нужно затронуть – это **оператор else**.

**Оператор else** в циклах выполняется только в том случае, если цикл выполнен успешно. Главная задача **оператора else**, это поиск объектов:
```py
my_str = 'abcdef'

i = 0

while i <= len(my_str) - 1:  
    if my_str[i] == 'g':  
        print("Item found!")  
        break
		
    print(my_str[i])  
    i += 1
	
else:  
    print("Item not found!")
```
В этом коде мы **разорвали цикл**, когда i равно 3. Это приводит к пропуску **оператора else**.

#### Задачи
1. Написать программу ввода неопределённого ряда целых чисел до тех пор, пока не будет введён 0. После ввода 0 программа должна вывести сообщение «Программа закончена».
2. Найти сумму ряда S = 15+16+17+...+n

#### For

Задача:
Есть строка, состоящая из букв разных регистров. Напишите код, который будет удалять символы верхнего регистра и выведет на печать оставшуюся строку.

```python
letters = 'ЫгВЫоЯСремДШНККАыкЩЙФа'
```
 
 Придумайте алгоритм решения. Чего не хватает для того, чтобы справиться с задачей? Повторения обращения к буквам строки. Для этого можно воспользоваться циклом.
 
Прежде чем приступить непосредственно к циклам `for`, стоит упомянуть неразрывно связанные с ним понятия:
**Итерация** - это общий термин, который описывает процедуру взятия элементов чего-то по очереди.

В более общем смысле, это последовательность инструкций, которая повторяется определенное количество раз или до выполнения указанного условия.

**Итерируемый объект** (iterable) - это объект, который способен возвращать элементы по одному. Кроме того, это объект, из которого можно получить итератор.

Примеры итерируемых объектов:
-   все последовательности: список, строка, кортеж
-   словари
-   файлы

Всегда следует помнить, что обилие циклов нагружает систему и увеличивает время обхода.

Цикл **for** работает очень занимательно. У него есть все те же операторы что и в `while`, то есть `break`, `continue`, `else`. Но ему не нужен **счетчик**. Зато ему очень нужна **итерируемая последовательность**.

Начнем знакомство с этим циклом с простейшей конструкции:
```python
for each in sequence:
	do smth
```
Для каждого из некоторой последовательности сделай что-то. Мы *итерируемся* по последовательности, беря по одному элементу за раз и обрабатывая его указанным способом.

Если вы помните, то со строкой тоже можно работать как с последовательностью. Давайте выведем на печать все символы строки по одному.
```python
s = 'long_string'
for symbol in s:
	print(symbol)

>>> l
>>> o
>>> n
>>> g
>>> _
>>> s
>>> t
>>> r
>>> i
>>> n
>>> g
```
Отлично! Но последовательность может быть не только строкой. Чтобы задать последовательность часто можно пользоваться функцией **range**.
- range(**старт**,[ **стоп**[, **шаг**]]) включает элемент старт, но не включает элемент стоп. Попробуем.

```python
for i in range(5):
	print(i)
```
Обратите внимание, правая граница не входит и элементы начинаются с нуля.
```python
for i in range(3, 5):
	print(i)
```

```python
for i in range(1, 10, 2):
	print(i)
```
Здесь вы уже заметили, что не так? Шаг 2 считает индексу элемента, а не по его значению, поэтому вопреки ожиданию мы получили нечетные числа.

Но конструкция с if не заканчивается на приведенных выше примерах. Иногда требуется использовать более сложные конструкции. Например,
```python
for num in range(40, 51):
    if num == 45:
        break
    print(num)

```
-   `break` — прерывает цикл и выходит из него;

Как думаете, какой вывод в консоль мы получим в этом случае?

```python
for num in range(40, 51):
    if num == 45:
        continue
    print(num)
```

Что же произойдет здесь?
-   `continue` — прерывает текущую итерацию и переходит к следующей.

В случае `continue` происходит похожая ситуация, только прерывается лишь одна итерация, а сам же цикл продолжается.

Теперь, когда мы знакомы с циклом for, попробуем все же решить задачу.
1. Нам нужно пройтись по каждой букве в строке, сделать это можно с помощью конструкции `for letter in letters`.
2. Далее у нас есть условие, что оставшиеся буквы должны быть маленькими, т.е. добавляем условие `if`. Проверяем, если буква маленькая, то оставляем ее.
3. Но где мы ее оставляем? Нам нужно хранилище, куда мы будем складывать "правильные буквы". Создадим пустую строку `clean_string = ''`. Теперь каждая правильная буква будет прибавляться к нашей строке-результату.
4. Теперь у нас есть изначальная строка с названием `letters` и результат очистки `clean_string`. Поскольку нас просили очистить исходную строку, т.е. `letters`, просто припавняем ее к очищенной. И выведем все на печать:

```python
letters = 'ЫгВЫоЯСремДШНККАыкЩЙФа'
clean_string = ''
for letter in letters:
	if letter.islower():
		clean_string += letter  # clean_string = clean_string + letter
letters = clean_string
print(letters)
```
#### Задачи
1. Вывести на экран 3 раза слово «Hello».
2. Напечатать столбиком все целые числа от а до b (значения а и b вводятся с клавиатуры).
3. Введите с клавиатуры количество и наименование множителей и выведите их произведение.
4. Введите с клавиатуры число и символ и напишите скрипт, который будет выводить квадрат из заданных символов величиной с заданное число.


### Дополнительная информация*

**Цикл for** может обходить любой итератор Python. Когда вы используете **for в словаре**, вы увидите, что он автоматически **перебирает ключи**. Вам не нужно указывать ключ for в **a\_dict.keys()** (впрочем, это также работает).

Eсли у нас двойная итерируемая последовательность, то можно итерироваться по 2м элементам сразу/
```py
dic = {'key':'value', 'key1':'value'}
for key, value in dic.items(): print(key, '-->', value)
# key --> value
# key1 --> value
```

Когда мы используем цикл for он вытаскивает из объекта метод **__iter__**, который являет собой поток данных. одноразовый. Затем он применяет к нему функцию **next()** и это есть одна итерация. Из потока данных при этом убирается вызванный элемент и в следующий раз next возвратит уже следующий, до тех пор пока не будет ошибки `stopiteration`.
(выполнять в консоли после набора слова python)
Проверим, что у строки есть указанные выше методы:
```python
>>>s = 'abc'
>>>dir(s)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']

iter_str = iter(s)
dir(iter_str)
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__length_hint__', '__lt__', '__ne__', '__new__', '__next__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__']

```
Мы убедились, что нужные нам методы присутсвуют, теперь попробуем воспользоваться ими:

```python
>>> s = 'abc'
>>> iter_str = iter(s)
>>> next(iter_str)
'a'
>>> next(iter_str)
'b'
>>> next(iter_str)
'c'
>>> next(iter_str)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

```

Реализуем цикл for через while:
```python
lst1 = [1,2,3,4,5]
lst1_iter = iter(lst1)
while True:
    try:
        word = next(lst1_iter)
        print(word)
    except StopIteration:
        break
```