## Кортежи

**Кортеж** - эта структура данных используется для хранения последовательности упорядоченных и *неизменяемых элементов*. 
Зачем нужны кортежи, если есть списки?
В отличие от списков, кортежи неизменяемы. Как только вы создали кортеж, значение какого‑либо его элемента уже нельзя изменить, как нельзя добавлять и удалять элементы.
Итого:
* защита от дурака
* меньший вес

Вашим первым **домашним заданием** будет найти в сети и прочитать, что такое изменяемые и неизменяемые объекты в питоне.

Как же задать кортеж?
* Литералы:
```python
cake = ('c','a','k','e')
```

Кортежи могут включать однородные и разнородные значения.
```python
mixed_type = ('C',0,0,'K','I','E')
```

* Запятая
```python
numbers_tuple = 1,2,3,4,5
print(type(numbers_tuple))
>>> <class 'tuple'>
```

* Функция:
```python
x = tuple('s')
```

Операции с кортежами.
Все операции над списками, не изменяющие список (сложение, умножение на число, методы index() и count() и некоторые другие операции). Можно также по-разному менять элементы местами и так далее.

Попробуем изменить 0 на «0»
```python
mixed_type = ('C',0,0,'K','I','E')
mixed_type[1] = "0"
>>> TypeError: 'tuple' object does not support item assignment
```
Ошибка появилась из-за попытки поменять значения внутри кортежа.

Кортежи очень похожи на списки. По сути, они являются неизменяемыми списками. Это значит, что после создания кортежа хранимые в нем значения нельзя удалять или менять. Добавлять новые также нельзя:
```python
numbers_tuple = (1,2,3,4,5)
numbers_list = [1,2,3,4,5] 
# Добавим число в кортеж 
numbers_tuple.append(6)
>>> AttributeError: 'tuple' object has no attribute 'append'
```

Ошибка появляется, потому что нельзя добавлять новые элементы в кортеж, что работает в случае со списками.

**Но зачем использовать этот тип данных, если он неизменяемый?**

Кортежи не только предоставляют доступ только для чтения к элементам, но и работают быстрее списков. Рассмотрим в качестве примера следующий код:
```python
import timeit
timeit.timeit('x=(1,2,3,4,5,6,7,8,9)', number=100000) 
>>> 0.0018976779974764213
timeit.timeit('x=[1,2,3,4,5,6,7,8,9]', number=100000) 
>>> 0.019868606992531568
```
Библиотека timeit измеряет время выполнения небольших фрагментов кода. `number` указывает количество запусков фрагмента кода.


**Какую роль играет неизменяемость в случае с кортежами?**

Согласно официальной документации Python неизменяемый — это «объект с фиксированным значением», но в отношении кортежей «значение» — это чересчур размытый термин. Лучше использовать `id`. `id` определяет расположения объекта в памяти.

Рассмотрим подробнее:

```python
# Кортеж 'n_tuple' со списком в качестве одного из его элементов.
n_tuple = (1, 1, [3,4])

# Элементы с одинаковым значением имеют одинаковый идентификатор.
id(n_tuple[0]) == id(n_tuple[1])

>>> True
```

```python
# Элементы с разным значением имеют разные идентификаторы.
id(n_tuple[0]) == id(n_tuple[2])
>>> False
```


```python
print(id(n_tuple[0]), id(n_tuple[2]))
>>> 4297148528, 4359711048
```

```python
n_tuple.append(5)
>>> AttributeError: 'tuple' object has no attribute 'append'
```

Добавить элемент в кортеж нельзя, поэтому появляется последняя ошибка AttributeError. Вот почему эта структура данных неизменна. Но всегда можно сделать вот так:

```python
n_tuple[2].append(5)
n_tuple
>>> (1, 1, [3, 4, 5])
```

Это позволяет изменять оригинальный кортеж? Куда в таком случае делась их неизменяемость?

Суть в том, что `id` списка в кортеже не меняется несмотря на добавленный в него элемент 5.

```python
id(n_tuple[2])
>>> 4359711048
```

Т.о. если вы планируете использовать постоянный набор значений для перебора, используйте кортеж вместо списка. Он будет работать быстрее. Плюс, это безопаснее, ведь такой тип данных защищен от записи.

### Стандартные операции с кортежами

**Срезы**
```python
numbers = (0,1,2,3,4,5)
numbers[0]
>>> 0
numbers[-1]
>>> 5
numbers[1:4]
>>> (1, 2, 3)
numbers[::2]
>>> (0, 2, 4)
numbers[::-1]
>>> (5, 4, 3, 2, 1, 0)
```

**Объединение кортежей**
Можно объединять кортежи для создания нового объекта. Операция объединения выполняет конкатенацию двух кортежей.
```python
x = (1,2,3,4)
y = (5,6,7,8)
# Объединение двух кортежей для формирования нового кортежа
z = x + y print(z)
>>> (1, 2, 3, 4, 5, 6, 7, 8)

y = [5,6,7,8]
z = x + y
print(z)
>>> TypeError: can only concatenate tuple (not "list") to tuple
```

Разрешается объединять только определенные типы данных. Так, попытка соединить кортеж и список закончится ошибкой.

**Умножение кортежей**
```python
x = (1,2,3,4)
z = x*2
print(z)
>>> (1, 2, 3, 4, 1, 2, 3, 4)
```

**Функции кортежей**
В отличие от списков у кортежей нет методов, таких как `append()`, `remove()`, `extend()`, `insert()` или `pop()` опять-таки из-за их неизменяемости. Но есть другие:

`count()` и `len()`
`count()` возвращает количество повторений элемента в кортеже.
```python
a = [1,2,3,4,5,5]
a.count(5)
>>> 2
```
len() — длину кортежа:
```python
a = (1,2,3,4,5)
print(len(a))
>>> 5
```

`any()`
Функцию any() можно использовать, чтобы определить являются ли элементы кортежа итерируемыми. Если да, то она вернет True.
```python
a = (1,)
print(any(a))
>>>True
```

Обратите внимание на запятую (,) в объявлении кортежа a. Если ее не указать при создании объекта с одним элементом? Python предположит, что вы по ошибке добавили лишнюю пару скобок (это ни на что не влияет), но тип данных в таком случае — это не кортеж. Поэтому важно не забывать использовать запятую при объявлении кортежа с одним элементом.

И снова к функции `any`. В булевом контексте значение элемента не имеет значения. Пустой кортеж вернет `False`, а кортеж с хотя бы одним элементом — `True`.
```python
b = ()
print(any(b))
>>> False
```

Функция может быть полезной, если кортеж вызывается? и нужно удостовериться, что он не пустой.

`tuple()`
Функция tuple() используется для конвертации данных в кортеж. Например, так можно превратить список в кортеж.
```python
a_list = [1,2,3,4,5]
b_tuple = tuple(a_list)
print(type(b_tuple))
>>> <class 'tuple'>
```

`min()` и `max()`
Функция max() возвращает самый большой элемент последовательности, а min() — самый маленький. Возьмем следующий пример:
```python
a = (1,2,3,4,5)
print(max(a))
print(min(a))
>>> 5
>>> 1
```
Эти функции можно использовать и для кортежей со строками.
```python
# Строка «Apple» автоматически преобразуется в последовательность символов.
a = ('Apple') 
print(max(a))
>>> p
```

`sum()`
С помощью этой функции можно вернуть сумму элементов в кортеже. Работает только с числовыми значениями.
```python
a = (1,2,3,4,5)
sum(a)
>>> 15
```

`sorted()`
Чтобы получить кортеж с отсортированными элементами, используйте sorted() как в следующем примере:
```python
a = (6,7,4,2,1,5,3)
sorted(a)
>>> [1, 2, 3, 4, 5, 6, 7]
```

Но важно отметить, что возвращаемый тип — список, а не кортеж. При этом последовательность в оригинальном объекте неизменна, а сам он остается кортежем.

**Присваивание нескольких значений**
Кортежи можно использовать для присваивания нескольких значений одновременно. Вот так:

```python
a = (1,2,3)
(one,two,three) = a
print(one)
>>> 1
```

`a` — это кортеж из трех элементов и `(one, two, three)` — кортеж трех переменных. Присваивание `(one, two, three)` кортежу `a` присваивает каждое значение `a` каждой переменной: `one`, `two` и `three` по очереди. Это удобно, если нужно присвоить определенному количеству переменных значений в кортеже.

Что еще почитать по теме?
[Кортежи в Python](https://pythonchik.ru/osnovy/kortezhi-v-python)

### Задачи
1. Напишите программу на Python для добавления элемента в кортеж.
2. Напишите программу на Python, чтобы получить 4-й элемент и 4-й  с конца элемент кортежа.
3. Напишите программу на Python, чтобы проверить, существует ли элемент в кортеже.
4. Напишите программу на Python для удаления элемента из кортежа.
5. Напишите функцию на Python для замены последнего значения кортежей в подаваемом списке на подаваемое число.  
Список образцов: [(10, 20, 40), (40, 50, 60), (70, 80, 90)]  
Ожидаемый результат: [(10, 20, 100), (40, 50, 100), (70, 80, 100)]

