## Словари, оформление кода

#### Разминка

Какой результат выведет программа?

![](https://lh4.googleusercontent.com/Cu--fSBfAlPCzQTQZeQLswWDGFDCqXqrGK5uvQ_sf5fhaaxjjDRUBD3patG4fu2Woc8bvXuYKGvJX-IGKtil5s0yiyjoLNXGwE7Hz1gWq3jfYeVVxK8Jee3NFTCLj28o0CAKF3Oi55SjGDjwC8H0)

![](https://lh4.googleusercontent.com/VdY8ceHBZC7T58FkU8WJ1wUfY3w4G8LiiDjXU7chL_1eYSNJ6TsEOt3aQ95B4S7769RjkaIP7Q4718g7dUo6z6rz4cF_MI9Kzy9GvmOzB0NUm0jGvxf_qhm8EgBfxgcrevkL3u6HPsnVp3BkD06p)

![](https://lh6.googleusercontent.com/ateUJpih6_8wZmCijl0MsotoLUZYTzeRMwxeygzIssZAFu0hvECmC-2iWMTiXRcUvX_xo374v8py422j9b97nevC3mp06RsXMfhxZao5V7QzvNNnTlOEcLdbk8RluzygODfsp2CWzRcFrbZNhCiS)

![](https://lh4.googleusercontent.com/DODGs6PNAx8EERFCmcawRIGINyprQ8kT1GbH57O-2gqQ7O07iNNybKqo1Q9aruDmureHyHmNC6PJd70tHtUVgm9rmNCVK35ukPW1JwW7kCqh_-26Tn1jRqhTADCL-yEISWl88_WCM7rJs2-HkaHl)

## Словари
Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Ключами в словарях могут быть только неизменяемые типы данных, такие как целые числа, строки, кортежи. Изменяемые типы данных не могут быть ключом.

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами:
* Литерал
 ```py
d = {'key1':'value', 'key2':'value2'}
```
* Функция
```py
 c = dict(key1 = 'value',  key2 = 'value1')
 # {'key1': 'value', 'key2': 'value1'}
 ```
* Метод fromkeys()
```py
e = dict.fromkeys(['a', 'b'])
# {'a': None, 'b': None}
f = dict.fromkeys(['a', 'b'], 100)
{'a': 100, 'b': 100}
```
Нельзя подать больше одного значения для всех ключей

* Генератор
```py
{ key:value for item in list if conditional }

slov1 = {i:i for i in range (1,11)if i%2 == 0}
>>> {2: 2, 4: 4, 6: 6, 8: 8, 10: 10}
```
* Функция zip()
```py
l1 = ['key1', 'key2']
l2 = ['value1', 'value2']
d1 = dict(zip(l1, l2))
>>> {'key1': 'value1', 'key2': 'value2'}
```

Обращение к элементу словаря можно реализовать несколькими способами:
```python
d = {'a': 2, 'b': 4, 'c': 9}
d['a']
d['t']
>>> 2
>>> 
Traceback (most recent call last):
  File "", line 1, in
    d['t']
KeyError: 't'
===============================
d.get('a')  # метод
d.get('t')
>>> 2
>>> None
```

Аналогичным образом можно добавить элемент в словарь:
```python
d = {'a': 2, 'b': 4, 'c': 9}

d['t'] = 10
d
>>> {'a': 2, 'b': 4, 'c': 9, 't': 10}
=================================

d.update({'r': 11})  # метод
d
>>> {'a': 2, 'b': 4, 'c': 9, 't': 10, 'r': 11}

```

Указанным выше способом можно не только добавить элемент, но и обновить его:
```python
d = {'a': 2, 'b': 4, 'c': 9}

d['a'] = 10
d
>>> {'a': 10, 'b': 4, 'c': 9}

=================================

d.update({'b': 11})  # метод
d
>>> {'a': 10, 'b': 11, 'c': 9}

```

#### Проход по словарю
Так как словарь уже является итератором, то можно подавать в цикл прямо его самого.
```python
dic = {'key1': 'value', 'key2': 'value1'}

for i in dic:
    print(i)
	
>>> key1
>>> key2
```

Проход по всем значениям
```python
dic = {'key1': 'value', 'key2': 'value1'}
for i in dic.values():
    print(i)
>>> value
>>> value1
```

Проход по всем парам значений
```python
dic = {'key1': 'value', 'key2': 'value1'}

for key, value in dic.items():
    print(key, '-->', value)
>>> key1 --> value
>>> key2 --> value1
```

#### Методы словаря
https://docs.python.org/3/library/stdtypes.html#mapping-types-dict

## Оформление кода

### Аннотации типов

![](http://risovach.ru/upload/2016/04/mem/xzibit_111651150_orig_.jpg)

Python — это язык с сильной динамической типизацией.

-   Сильная — значит, что язык не допускает неявных приведений типов в неоднозначных ситуациях или когда будет утрачена точность, например, нельзя “сложить” число и строку.
-   Динамическая — значит, что тип переменной определяется во время присваивания ей значения и может изменяться по ходу программы.

Такая система типов — это очень удачный компромисс между простотой разработки и надежностью написанных программ, но она не лишена недостатков.

Например, объявления переменных с типами в языках со статической типизацией, кроме своего основного назначения — инструкций компилятору или интерпретатору, ещё и помогают программисту лучше понимать написанный код, служат своеобразной документацией. Динамическая типизация не в состоянии этого дать.

Раньше, когда на Python писали в основном небольшие скрипты, это не было такой уж острой проблемой, потому что всю программу за разумный промежуток времени можно было охватить взглядом и понять. В последнее время язык стал значительно популярнее.

Сегодня на Python написано много сложных систем из сотен файлов и сотен тысяч строк кода. В таких обстоятельствах документирующее свойство системы типов становится очень полезным. В достаточно крупной кодовой базе при отсутствии информации о типах очень сложно угадать (а только гадать и остаётся), какие же именно объекты циркулируют по программе.

По этим соображениям, в Python 3.5 появился специальный синтаксис для объявления типов параметров функций и их возвращаемых значений.

Зачем писать тайп-аннотации?

-   документация для разработчиков;
-   сторонние утилиты и библиотеки могут использовать эту информацию по своему усмотрению, например, выполняя проверки типов или приводя данные к нужному типу.

**Простые типы**
``` python
def greeting(name: str = "world") -> str:
    return "Hello, " + name
```
Типы параметров, принимаемых функцией, записываются после имени параметра через знак двоеточия, но перед значением по умолчанию, если оно присутствует. Возвращаемое значение функции записывается после знака “стрелки”.
Точно так же можно использовать для тайп-аннотаций и любые другие базовые (примитивные) типы в Python: `int`, `float`, `bool`, `str`, `bytes`, `None` и вообще практически что угодно.
Вот так можно зааннотировать функцию, которая принимает строку и булевый аргумент, но ничего не возвращает:

```python
def print_hello(name: str, upper: bool = False) -> None:
	if upper:
		name = name.upper()
		print("Hello,", name)
```
В примере выше попробуем подать не строку, а число, и увидим в PyCharm, что это ошибка.

**Более сложные типы**
Перейдем к более сложным типам, таким как списки, кортежи, словари и множества. Можно аннотировать в лоб, используя сами имена классов:
```python
primes: list
stock_prices: dict
```
Это не слишком информативно, потому что кроме самого типа контейнера было бы ещё полезно знать, какие данные он в себе содержит.  Например, что такое primes? Список чего?

В Python до версии 3.9 для этого придётся использовать отдельные классы из модуля `typing`, потому что стандартные классы не представляют такой функциональности. Делается это при помощи квадратных скобок, как будто мы извлекаем что-то по индексу:

```python
from typing import List, Tuple, Dict, Set

# тип всех элементов списка
primes: List[int]

# тип каждого элемента кортежа
person_info: Tuple[str, int, float, float]

# тип ключей, тип значений
stock_prices: Dict[str, float]

# тип всех элементов множества
valid_answers: Set[str]
```

Начиная с Python 3.9 можно использовать стандартные классы в точно таких же целях, ничего ниоткуда не импортируя:

```python
# будет работать только начиная с Python 3.9!

# тип всех элементов списка
primes: list[int]

# тип каждого элемента кортежа
person_info: tuple[str, int, float, float]

# тип ключей, тип значений
stock_prices: dict[str, float]

# тип всех элементов множества
valid_answers: set[str]
```

Согласитесь, так намного понятнее. Сразу видно, какой тип данных лежит внутри контейнера.

Информация взята из источника: https://semakin.dev/2020/06/type_hints/

### Докстринги
**Что такое Docstring?**

Документационная строка — это строковый литерал, являющийся первой инструкцией в определении модуля, функции, класса или метода.
Для согласованности всегда используйте """тройные двойные кавычки""" вокруг документационной строки.

Существует две формы docstring: однострочные и многострочный.  
  
**Однострочные документационные строки**
Однострочные строки используются для очевидных случаев и они должны действительно находится на одной строке. Например:  
```python
def kos_root():
    """Вернёт путь к папке root KOS"""
    global _kos_root
    if _kos_root: return _kos_root
    ...
```
  
Замечания:  
-   Тройные кавычки используются даже если строка помещается на одной линии. Это облегчает последующее расширение документации.
-   Закрывающие кавычки находятся на той же строке, что и открывающие. Для однострочных docstring это выглядит лучше.
-   Ни до, ни после документации не пропускаются строки. Код пишется сразу же на следующей линии
-   Документационная строка — это «фраза», заканчивающаяся точкой. Она описывает эффект функции или метода в командном тоне («Сделай это», «Верни это»), не являясь простым описанием. Например, не пишите подобные документации: «Возвращает путь ...».  
-   Однострочная документация **НЕ** должна быть простой «подписью», повторяющей параметры функции/метода (которые могут быть получены путем инспектирования). Не делайте так:  

    ```python
    def function(a, b):
        """function(a, b) -> list"""
    ```

**Многострочные документационные строки**

Многострочные документации состоят из сводной строки (summary line) имеющей такую же структуру, как и однострочный docstring, после которой следует пустая линия, а затем более сложное описание. «Summary line» может быть использована средствами автоматического документирования; поэтому так важно располагать её на одной строке и после делать пропуск в одну линию. Сводная строка пишется сразу после открывающихся кавычек, но допускается сделать перенос и начать со следующей строки. При этом, весь docstring должен иметь такой же отступ, как и открывающие кавычки первой строки.


Теперь мы с вам всегда будем использовать докстринги и аннотации типов в своих работах.

### Задачи
1.  Напишите скрипт Python для добавления ключа в словарь. Перейти к редактору
		Пример словаря: {0: 10, 1: 20}
		Ожидаемый результат: {0: 10, 1: 20, 2: 30}
		
2. Напишите скрипт Python для объединения следующих словарей для создания нового. Перейти к редактору
		Пример словаря:
		dic1 = {1:10, 2:20}
		dic2 = {3:30, 4:40}
		dic3 = {5: 50,6: 60}
		Ожидаемый результат: {1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}

3. Напишите функцию, чтобы проверить, существует ли данный ключ в словаре.
Пример словаря d = {1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}

4. Напишите скрипт Python для генерации и печати словаря, который содержит число (от 1 до n, вводится с клавиатуры) в форме (x, x * x).
		Пример словаря (n = 5):
		Ожидаемый результат: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
		
5. Напишите функцию to_dict(lst), которая принимает аргумент в виде списка и возвращает словарь, в котором каждый элемент списка является и ключом и значением. Предполагается, что элементы списка будут соответствовать правилам задания ключей в словарях. 

